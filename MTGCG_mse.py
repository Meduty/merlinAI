# File: MTGCG-mse.py
# Description: Converts Magic: The Gathering card data generated by MTGCG API
#              into Magic Set Editor (MSE) compatible format.
# Author: Merlin Duty-Knez
# Created: [2025-07-29]
# Dependencies: Python 3.8+, requests, json
# Usage:
#     python MTGCG-mse.py
#
# Notes:
# - This parser expects input in MTGCG API JSON format.
# - Outputs data structured for use in MSE (Magic Set Editor) .mse-set format.
# - Validates fields, maps MTGCG keys to MSE keys, and sanitizes special characters.
# - Designed to be extensible for custom card attributes and rules text.

# MTGCG-mse.py
import json
from datetime import datetime

import logging

import zipfile
import os

import shutil

from dotenv import load_dotenv
# Load environment variables from .env file
load_dotenv()

import yaml

import urllib.request

import time
from openai import OpenAI

import imagesSD

from tqdm import tqdm
from tqdm.contrib.logging import logging_redirect_tqdm

from concurrent.futures import ThreadPoolExecutor, as_completed

# Logging setup
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

config = yaml.safe_load(open("config.yml"))



API_KEY = os.getenv("API_KEY")

max_retries = config["http_config"].get("retries", 3)
retry_delay = config["http_config"].get("retry_delay", 10)
timeout = config["http_config"].get("timeout", 60)  # seconds

image_method = config["mtgcg_mse_config"].get("image_method", "none")

model_swap_chance = config["SD_config"].get("model_swap_chance", 20)

sleepy_time = config["square_config"].get("sleepy_time", 0)
concurrency = int(config["square_config"].get("concurrency", 1))

BAR_FMT = (
    "{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} "
    "[Elapsed: {elapsed} | Remaining: {remaining} | Avg: {rate_fmt}]"
)


# --- CONFIGURABLE STATIC HEADER ---
HEADER_TEMPLATE = """mse_version: 2.0.2
game: magic
game_version: 2024-10-01
stylesheet: m15-altered
stylesheet_version: 2024-09-23
set_info:
	symbol: 
	masterpiece_symbol: 
	automatic_reminder_text: 
	sort_multicolor_in_pairs: yes
	sort_hybrid_in_pairs: yes
styling:
	magic-m15-altered:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	magic-m15-mainframe-dfc:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	magic-m15-mainframe-planeswalker:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		overlay: 
"""

def ask_overlord_for_loyalty(index: int, card: dict, ai: OpenAI):

    if ai is None:
        ai = OpenAI(api_key=API_KEY)

    loyalty = 0

    card_data = {
        "name": card["name"],
        "manaCost": card["manaCost"],
        "typeLine": card["typeLine"],
        "oracleText": card["oracleText"],
        "colorIdentity": card["colorIdentity"],
        "rarity": card["rarity"],
    }

    input = [
        {
            "role": "system",
            "content": "You are an assistant who works as a Magic: The Gathering card designer. You review Planeswalker cards and propose their starting Loyalty. OUTPUT MUST BE A SINGLE INTEGER EQUAL TO THE PROPOSED STARTING LOYALTY. DO NOT EXPLAIN THE CARD OR YOUR REASONING IN YOUR FINAL OUTPUT. The output must follow Magic the Gathering card power balancing principles",
        },
        {"role": "user", "content": json.dumps(card_data)},
    ]

    for attempt in range(1, max_retries + 1):
        try:
            response = ai.responses.create(
                model="gpt-5",
                input=input,
                timeout=timeout
            )
            if response.status in ['failed', 'cancelled']:
                raise response
            break  # Exit loop if request succeeded
        except Exception as e:
            logging.error(f"[Card #{index+1}] Attempt {attempt} failed: {e}")
            if attempt == max_retries:
                raise # Re-raise last exception if all retries failed
            time.sleep(retry_delay)  # Wait before retrying

    # Check if the request was successful
    if response.status == "completed":
        logging.debug(f"[Card #{index+1}] Response from OpenAI: {response.model_dump()}")
        loyalty = response.model_dump()["output"][1]["content"][0]["text"]
        logging.info(f"[Card #{index+1}] Overlord says Loyalty: {loyalty}")
        time.sleep(sleepy_time)

    else:
        logging.info(f"[Card #{index+1}] Error:", response.status, response.text)
        time.sleep(sleepy_time)

    return loyalty

def card_to_mse_block(index: int, card: dict, ai: OpenAI):
    # Extracting fields from the card JSON
    name = card.get("name", "Unknown Card")

    logging.info(f"[Card #{index+1}] Adding card: {name}")
    time.sleep(sleepy_time)

    image_noext = card.get("id", "")
    manaCost = card.get("manaCost", "")
    typeLine = card.get("typeLine", "")
    if "\u2014" in typeLine:
        supertype = typeLine.split("\u2014")[0].strip()
        subtype = typeLine.split("\u2014")[1].strip()
    else:
        supertype, subtype = typeLine, ""
    colorIdentity = card.get("colorIdentity", "")
    rarity = card.get("rarity").lower()
    oracle = card.get("oracleText", "")
    flavour = card.get("flavorText", "")
    pt = (
        card.get("pt", "")
        .replace("Starting Loyalty: ", "")
        .replace("Loyalty: ", "")
        .replace("None", "")
        .replace(":", "")
        .strip()
    )

    if "Planeswalker" in typeLine and pt == "":
        logging.info(f"[Card #{index+1}] Found Planeswalker with not P/T -- Interpreting rules text for loyalty counters.")
        time.sleep(sleepy_time)
        texts = [
            "{iname} enters the battlefield with {iloyalty} loyalty counters.",
            "{iname} enters the battlefield with {iloyalty} Loyalty counters.",
            "Starting Loyalty: {iloyalty}",
            "Starting loyalty: {iloyalty}",
            "Loyalty: {iloyalty}",
        ]
        for loyalty in range(100):
            for text in texts:
                text = text.format(iname=name, iloyalty=loyalty)
                logging.debug(f"[Card #{index+1}] Looking for '{text}' in oracle text ")
                if text in oracle:
                    logging.info(
                        f"[Card #{index+1}] Found '{text}' in oracle text"
                    )
                    time.sleep(sleepy_time)
                    oracle = oracle.replace(text, "").strip()
                    pt = f"{loyalty}"
                    break
            else:
                continue  # only executed if the inner loop did NOT break
            break  # only executed if the inner loop DID break

        else:

            logging.info(f"[Card #{index+1}] Could not interpret loyalty from oracle text. Asking AI Overlord instead")
            time.sleep(sleepy_time)
            pt = ask_overlord_for_loyalty(index, card, ai=ai)

    if "/" in pt:
        power, toughness = pt.split("/") if pt else ("", "")
    else:
        power = pt
        toughness = ""
    dt = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Create text for the MSE block
    block = f"""card:
	has_styling: true
	styling_data:
		text_box_mana_symbols: magic-mana-small.mse-symbol-font
		level_mana_symbols: magic-mana-large.mse-symbol-font
		overlay: 
	notes:
		raw:
		{name}
		{manaCost}
		{typeLine}
		{colorIdentity}
		{rarity}
		{oracle.replace("\n", "\n\t\t")}
		{flavour.replace("\n", "\n\t\t")}
		({pt})
	time_created: {dt}
	time_modified: {dt}
	name: {name}
	casting_cost: {manaCost.replace("{", "").replace("}", "")}
	image: {image_noext}.png
	image_2: 
	mainframe_image: 
	mainframe_image_2: 
	super_type: <word-list-type-en>{supertype}</word-list-type-en>
	sub_type: <word-list-type-en>{subtype}</word-list-type-en>
	rarity: {rarity}
	rule_text:
		{oracle.replace("\n\n","\n").replace("\n", "\n\t\t").replace("{", "[").replace("}", "]").replace("âˆ’", "-")}
	flavor_text:
		{flavour.replace("\n", "\n\t\t")}
	power: {power}
	toughness: {toughness}
	card_code_text: 
	card_code_text_2: 
	card_code_text_3: 
	copyright: 
	copyright_2: 
"""

    return block


def convert_cards(json_cards, ai=None):
    """
    Threaded converter with order-preserving assembly.
    Falls back to single-thread if concurrency <= 1.
    """
    total = len(json_cards)
    

    # Single-thread fast path (keeps your original behavior)
    if concurrency <= 1:
        parts = [HEADER_TEMPLATE]
        for i, card in enumerate(
            tqdm(json_cards, desc="Add mse card blocks", unit="card", bar_format=BAR_FMT, dynamic_ncols=True)
        ):
            parts.append(card_to_mse_block(i, card, ai=ai))
        return "".join(parts)

    # Threaded path
    results = [None] * total  # index-aligned storage to preserve order

    def _worker(i, card):
        # Pass ai=None so ask_overlord_for_loyalty creates a client per thread when needed
        return i, card_to_mse_block(i, card, ai=None)

    with tqdm(total=total, desc="Add mse card blocks", unit="card", bar_format=BAR_FMT, dynamic_ncols=True) as pbar:
        with ThreadPoolExecutor(max_workers=concurrency) as ex:
            futures = [ex.submit(_worker, i, card) for i, card in enumerate(json_cards)]
            for fut in as_completed(futures):
                i, block = fut.result()  # let exceptions surface; your main already logs nicely
                results[i] = block
                pbar.update(1)

    return HEADER_TEMPLATE + "".join(results)

def download_images(cards, output_dir, on_done=None):
    """
    Concurrent image downloader.
    - Respects config['square_config']['concurrency'] if present.
    - Calls on_done(1) once per card (even on failure or missing URL).
    """
    os.makedirs(output_dir, exist_ok=True)
    concurrency = int(config.get("square_config", {}).get("concurrency", 4))
    # Use your existing HTTP timeout if set; fall back to 60s
    http_timeout = int(config.get("http_config", {}).get("timeout", 60))

    def _worker(i_card):
        i, card = i_card
        name = card.get("name", f"#{i+1}")
        logging.info(f"[#{i+1}] Downloading image for {name}...")
        try:
            time.sleep(sleepy_time)  # keep your throttle if desired
            image_url = card.get("imageUrl")
            if not image_url:
                logging.warning(f"[#{i+1}] No image URL found for {name}. Skipping.")
                return False

            image_path = os.path.join(output_dir, f"{card['id']}.png")

            # Stream and save with a per-request timeout
            req = urllib.request.Request(image_url)
            with urllib.request.urlopen(req, timeout=http_timeout) as resp, open(image_path, "wb") as out:
                out.write(resp.read())

            return True
        except Exception as e:
            logging.error(f"[#{i+1}] Failed to download image for {name}: {e}")
            return False

    # Submit all tasks
    with ThreadPoolExecutor(max_workers=concurrency) as ex:
        futures = [ex.submit(_worker, (i, card)) for i, card in enumerate(cards)]
        for fut in as_completed(futures):
            # ensure the outer progress bar advances once per card
            if on_done:
                try:
                    on_done(1)
                except Exception:
                    # don't let a callback error kill the loop
                    pass
            # surface exceptions if you want to crash on unexpected errors:
            # _ = fut.result()

def _move_generated(cards, src_dir: str, dst_dir: str) -> None:
    os.makedirs(dst_dir, exist_ok=True)
    for card in cards:
        src = os.path.join(src_dir, f"{card['id']}.png")
        dst = os.path.join(dst_dir, f"{card['id']}.png")
        if not os.path.exists(src):
            logging.warning(f"Image for {card['name']} not found in {src_dir}.")
            continue
        try:
            shutil.move(src, dst)
            logging.info(f"Moved image for {card['name']} to {dst}")
            time.sleep(sleepy_time)
        except Exception as e:
            logging.error(f"Failed to move image for {card['name']}: {e}")

def _handle_download(cards, output_dir, on_done):
    logging.info("Using download method for image retrieval.")
    time.sleep(sleepy_time)
    download_images(cards, output_dir, on_done=on_done)

def _handle_localsd(cards, output_dir, on_done):
    logging.info("Using local SD for image generation.")
    time.sleep(sleepy_time)
    out_dir = imagesSD.generate_images_from_dict(
        cards,
        option_change_chance=model_swap_chance,
        on_done=on_done,  # overall bar ticks as each image finishes
    )
    _move_generated(cards, src_dir=out_dir, dst_dir=output_dir)

def _handle_none(cards, output_dir, on_done):
    logging.info("Skipping image download as per configuration.")
    time.sleep(sleepy_time)
    # still complete the bar so UX matches "no work to do"
    for _ in cards:
        on_done()

def get_images(cards, output_dir, method="download"):
    total = len(cards)
    with tqdm(total=total, desc="Images", unit="img",
              dynamic_ncols=True, bar_format=BAR_FMT, position=1) as pbar:

        def mark_done(_=None):
            pbar.update(1)

        handlers = {
            "download": _handle_download,
            "localSD": _handle_localsd,
            "none": _handle_none,
        }

        handler = handlers.get(method)
        if handler is None:
            raise ValueError(f"Unknown image retrieval method: {method}")

        try:
            handler(cards, output_dir, mark_done)
        except Exception as e:
            logging.error(f"Error in get_images ({method}): {e}")


def export_to_zip(output_text, cards, image_method="download", output_dir="out/mse-out", filename="set"):
    os.makedirs(output_dir, exist_ok=True)
    set_path = os.path.join(output_dir, filename)
    with open(set_path, "w", encoding="utf-8") as f:
        f.write(output_text)
    get_images(cards, output_dir, method=image_method)
    with zipfile.ZipFile(f"{output_dir}.mse-set", "w", zipfile.ZIP_DEFLATED) as zipf:
        for root, _, files in os.walk(output_dir):
            for file in files:
                file_path = os.path.join(root, file)
                arcname = os.path.relpath(file_path, output_dir)
                zipf.write(file_path, arcname=arcname)


if __name__ == "__main__":
    with logging_redirect_tqdm():
        with open("generated_cards.json", "r", encoding="utf-8") as f:
            cards_data = json.load(f)

        openai_client = None

        logging.info("=== Starting conversion ===")
        time.sleep(sleepy_time)
        mse_output = convert_cards(cards_data, ai=openai_client)

        logging.info("=== Exporting to .mse-set ===")
        time.sleep(sleepy_time)
        export_to_zip(
            mse_output,
            cards_data,
            image_method=image_method,
            output_dir="out/mse-out",
            filename="set"
        )

        logging.info("Packaged set into out/mse-out.mse-set")
        time.sleep(sleepy_time)
        logging.info("=== Conversion complete ===")
        time.sleep(sleepy_time)

        
